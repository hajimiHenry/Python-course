# Day14：函数和模块（低障碍版）

> 目标：在不改变原教程知识点的前提下，把内容重排成更容易阅读、理解和复习的结构。

---

## 1. 为什么要学函数：先看一个“重复代码”问题

先看一个数学题：

$$
x_{1} + x_{2} + x_{3} + x_{4} = 8
$$

这个问题等价于：
- 把 8 个苹果分成 4 组，每组至少 1 个。
- 在 8 个苹果之间有 7 个空隙，放 3 个隔板。

所以方案数是：

$$
C_7^3 = 35
$$

组合数公式：

$$
C_m^n = \frac {m!} {n!(m-n)!}
$$

用我们当前会的知识，可以先分别算出 `m!`、`n!`、`(m-n)!`，再做除法：

```python
"""
输入m和n，计算组合数C(m,n)的值

Version: 1.0
Author: 骆昊
"""

m = int(input('m = '))
n = int(input('n = '))
# 计算m的阶乘
fm = 1
for num in range(1, m + 1):
    fm *= num
# 计算n的阶乘
fn = 1
for num in range(1, n + 1):
    fn *= num
# 计算m-n的阶乘
fk = 1
for num in range(1, m - n + 1):
    fk *= num
# 计算C(M,N)的值
print(fm // fn // fk)
```

输入：

```text
m = 7
n = 3
```

输出：

```text
35
```

### 关键问题

这段代码里，“求阶乘”的逻辑写了 3 次，属于重复代码。

Martin Fowler 有一句很有名的话：
- 代码有很多坏味道，重复是最坏的一种。

这就是函数出现的意义：
- 把可复用功能封装起来。
- 需要时直接调用，不再重复写。

---

## 2. 什么是函数：定义 + 调用

### 2.1 数学函数 vs Python 函数

数学里常见：
- `y = f(x)`
- `z = g(x, y)`

Python 里是一致的：
- 函数名
- 参数（自变量）
- 返回值（因变量）

### 2.2 定义函数的基本规则

- 用 `def` 定义函数。
- 参数写在函数名后的圆括号里。
- 用 `return` 返回结果。
- 没有 `return` 时，返回 `None`。
- 没有参数也可以，但圆括号必须保留。
- 函数体通过缩进表示代码块。

函数定义结构示意图（与原教程一致）：

<img src="../Python-100-Days/Day01-20/res/day14/function_definition.png" style="zoom:45%;">

### 2.3 把“求阶乘”重构成函数

重构的定义：
- 在不改变代码执行结果的前提下，调整代码结构。

```python
"""
输入m和n，计算组合数C(m,n)的值

Version: 1.1
Author: 骆昊
"""


# 通过关键字def定义求阶乘的函数
# 自变量（参数）num是一个非负整数
# 因变量（返回值）是num的阶乘
def fac(num):
    result = 1
    for n in range(2, num + 1):
        result *= n
    return result


m = int(input('m = '))
n = int(input('n = '))
# 计算阶乘的时候不需要写重复的代码而是直接调用函数
# 调用函数的语法是在函数名后面跟上圆括号并传入参数
print(fac(m) // fac(n) // fac(m - n))
```

一句话总结：
- 函数就是“可重复使用的功能积木”。

---

## 3. 先用现成函数，再考虑自己写

Python `math` 模块已经有 `factorial`。

### 3.1 直接导入函数使用

```python
"""
输入m和n，计算组合数C(m,n)的值

Version: 1.2
Author: 骆昊
"""
from math import factorial

m = int(input('m = '))
n = int(input('n = '))
print(factorial(m) // factorial(n) // factorial(m - n))
```

### 3.2 给导入函数取别名

```python
"""
输入m和n，计算组合数C(m,n)的值

Version: 1.3
Author: 骆昊
"""
from math import factorial as f

m = int(input('m = '))
n = int(input('n = '))
print(f(m) // f(n) // f(m - n))
```

核心原则：
- 有现成函数就优先复用，不要“重复发明轮子”。

---

## 4. 函数参数：一口气看全

### 4.1 位置参数和关键字参数

示例：判断三条边能否构成三角形。

```python
def make_judgement(a, b, c):
    """判断三条边的长度能否构成三角形"""
    return a + b > c and b + c > a and a + c > b
```

位置参数（按顺序传）：

```python
print(make_judgement(1, 2, 3))  # False
print(make_judgement(4, 5, 6))  # True
```

关键字参数（参数名=值）：

```python
print(make_judgement(b=2, c=3, a=1))  # False
print(make_judgement(c=6, b=4, a=5))  # True
```

### 4.2 强制位置参数（`/`）和命名关键字参数（`*`）

`/` 前面的参数：只能按位置传。

```python
# /前面的参数是强制位置参数
def make_judgement(a, b, c, /):
    """判断三条边的长度能否构成三角形"""
    return a + b > c and b + c > a and a + c > b


# 下面的代码会产生TypeError错误，错误信息提示“强制位置参数是不允许给出参数名的”
# TypeError: make_judgement() got some positional-only arguments passed as keyword arguments
# print(make_judgement(b=2, c=3, a=1))
```

> 说明：强制位置参数是 Python 3.8 引入的新特性。

`*` 后面的参数：只能按“关键字”传。

```python
# *后面的参数是命名关键字参数
def make_judgement(*, a, b, c):
    """判断三条边的长度能否构成三角形"""
    return a + b > c and b + c > a and a + c > b


# 下面的代码会产生TypeError错误，错误信息提示“函数没有位置参数但却给了3个位置参数”
# TypeError: make_judgement() takes 0 positional arguments but 3 were given
# print(make_judgement(1, 2, 3))
```

### 4.3 默认值参数

```python
from random import randrange


# 定义摇色子的函数
# 函数的自变量（参数）n表示色子的个数，默认值为2
# 函数的因变量（返回值）表示摇n颗色子得到的点数
def roll_dice(n=2):
    total = 0
    for _ in range(n):
        total += randrange(1, 7)
    return total


# 如果没有指定参数，那么n使用默认值2，表示摇两颗色子
print(roll_dice())
# 传入参数3，变量n被赋值为3，表示摇三颗色子获得点数
print(roll_dice(3))
```

再看一个简单示例：

```python
def add(a=0, b=0, c=0):
    """三个数相加求和"""
    return a + b + c


# 调用add函数，没有传入参数，那么a、b、c都使用默认值0
print(add())         # 0
# 调用add函数，传入一个参数，该参数赋值给变量a, 变量b和c使用默认值0
print(add(1))        # 1
# 调用add函数，传入两个参数，分别赋值给变量a和b，变量c使用默认值0
print(add(1, 2))     # 3
# 调用add函数，传入三个参数，分别赋值给a、b、c三个变量
print(add(1, 2, 3))  # 6
```

注意：
- 带默认值的参数，必须放在不带默认值参数的后面。
- 否则报错：`non-default argument follows default argument`。

### 4.4 可变参数：`*args` 和 `**kwargs`

可变位置参数：接收 0 个或任意多个位置参数。

```python
# 用星号表达式来表示args可以接收0个或任意多个参数
# 调用函数时传入的n个参数会组装成一个n元组赋给args
# 如果一个参数都没有传入，那么args会是一个空元组
def add(*args):
    total = 0
    # 对保存可变参数的元组进行循环遍历
    for val in args:
        # 对参数进行了类型检查（数值型的才能求和）
        if type(val) in (int, float):
            total += val
    return total


# 在调用add函数时可以传入0个或任意多个参数
print(add())         # 0
print(add(1))        # 1
print(add(1, 2, 3))  # 6
print(add(1, 2, 'hello', 3.45, 6))  # 12.45
```

可变关键字参数：接收 0 个或任意多个“参数名=参数值”。

```python
# 参数列表中的**kwargs可以接收0个或任意多个关键字参数
# 调用函数时传入的关键字参数会组装成一个字典（参数名是字典中的键，参数值是字典中的值）
# 如果一个关键字参数都没有传入，那么kwargs会是一个空字典
def foo(*args, **kwargs):
    print(args)
    print(kwargs)


foo(3, 2.1, True, name='骆昊', age=43, gpa=4.95)
```

输出：

```text
(3, 2.1, True)
{'name': '骆昊', 'age': 43, 'gpa': 4.95}
```

---

## 5. 为什么要用模块：解决命名冲突

最简单的冲突场景：同一个文件里出现同名函数。

```python
def foo():
    print('hello, world!')


def foo():
    print('goodbye, world!')

    
foo()  # 大家猜猜调用foo函数会输出什么
```

在团队协作里，这类冲突更常见。解决方式：
- Python 中每个 `.py` 文件就是一个模块（module）。
- 使用“完全限定名”调用函数：`模块名.函数名`。

`module1.py`

```python
def foo():
    print('hello, world!')
```

`module2.py`

```python
def foo():
    print('goodbye, world!')
```

`test.py`

```python
import module1
import module2

# 用“模块名.函数名”的方式（完全限定名）调用函数，
module1.foo()  # hello, world!
module2.foo()  # goodbye, world!
```

### 5.1 模块也可以取别名

`test.py`

```python
import module1 as m1
import module2 as m2

m1.foo()  # hello, world!
m2.foo()  # goodbye, world!
```

### 5.2 `from...import...` 的写法与风险

可以直接从模块导入函数：

`test.py`

```python
from module1 import foo

foo()  # hello, world!

from module2 import foo

foo()  # goodbye, world!
```

风险：
- 如果导入两个同名函数，后导入的会覆盖先导入的。

`test.py`

```python
from module1 import foo
from module2 import foo

foo()  # goodbye, world!
```

解决：给导入函数起别名。

`test.py`

```python
from module1 import foo as f1
from module2 import foo as f2

f1()  # hello, world!
f2()  # goodbye, world!
```

---

## 6. 标准库模块和内置函数

标准库里常用模块示例：
- `random`：随机数、随机抽样
- `time`：时间相关操作
- `math`：正弦、余弦、指数、对数等数学函数

还有一类函数不用 `import` 就能用，叫内置函数。常见如下：

| 函数    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| `abs`   | 返回一个数的绝对值，例如：`abs(-1.3)`会返回`1.3`。           |
| `bin`   | 把一个整数转换成以`'0b'`开头的二进制字符串，例如：`bin(123)`会返回`'0b1111011'`。 |
| `chr`   | 将Unicode编码转换成对应的字符，例如：`chr(8364)`会返回`'€'`。 |
| `hex`   | 将一个整数转换成以`'0x'`开头的十六进制字符串，例如：`hex(123)`会返回`'0x7b'`。 |
| `input` | 从输入中读取一行，返回读到的字符串。                         |
| `len`   | 获取字符串、列表等的长度。                                   |
| `max`   | 返回多个参数或一个可迭代对象中的最大值，例如：`max(12, 95, 37)`会返回`95`。 |
| `min`   | 返回多个参数或一个可迭代对象中的最小值，例如：`min(12, 95, 37)`会返回`12`。 |
| `oct`   | 把一个整数转换成以`'0o'`开头的八进制字符串，例如：`oct(123)`会返回`'0o173'`。 |
| `open`  | 打开一个文件并返回文件对象。                                 |
| `ord`   | 将字符转换成对应的Unicode编码，例如：`ord('€')`会返回`8364`。 |
| `pow`   | 求幂运算，例如：`pow(2, 3)`会返回`8`；`pow(2, 0.5)`会返回`1.4142135623730951`。 |
| `print` | 打印输出。                                                   |
| `range` | 构造一个范围序列，例如：`range(100)`会产生`0`到`99`的整数序列。 |
| `round` | 按照指定的精度对数值进行四舍五入，例如：`round(1.23456, 4)`会返回`1.2346`。 |
| `sum`   | 对一个序列中的项从左到右进行求和运算，例如：`sum(range(1, 101))`会返回`5050`。 |
| `type`  | 返回对象的类型，例如：`type(10)`会返回`int`；而` type('hello')`会返回`str`。 |

---

## 7. 全文总结（和原教程一致）

- 函数是对“功能相对独立且会重复使用的代码”的封装。
- 学会定义函数和调用函数，代码质量会明显提升。
- Python 标准库已经提供了大量可复用模块和函数，优先复用。
- 当现有函数不满足需求时，再自定义函数。
- 自定义函数通常按模块（文件）组织，便于避免命名冲突、提高可维护性。

# 16. 函数使用进阶 (Advanced Function Usage)

在前面的章节中，我们已经学习了函数的基本定义和使用。为了让我们编写的代码更加灵活、简洁和高效，本章节将重点介绍 Python 函数的两个高级特性：**装饰器（Decorators）** 和 **递归调用（Recursion）**。

---

## 1. 装饰器 (Decorators)

### 1.1 什么是装饰器？
装饰器本质上是一个**高阶函数**，它接收一个函数作为参数，并返回一个新的函数。
*   **核心作用**：在不修改原函数代码的前提下，为函数**增加额外的功能**（如：日志记录、性能测试、权限校验等）。
*   **设计原则**：对扩展开放，对修改关闭（OCP原则）。

### 1.2 为什么需要装饰器？
假设我们有两个函数 `download` (下载) 和 `upload` (上传)，我们需要统计它们的执行时间。

**❌ 原始方案：代码重复**
如果在每个函数内部都写一遍计时代码，会导致大量重复，难以维护。

```python
import time
import random

def download(filename):
    start = time.time()
    print(f'开始下载 {filename}...')
    time.sleep(random.random() * 2)  # 模拟耗时
    print(f'{filename} 下载完成.')
    end = time.time()
    print(f'耗时: {end - start:.2f}秒')
```

**✅ 优化方案：使用装饰器**
我们可以将“计时”这个通用功能提取出来，封装成一个装饰器 `record_time`。

```python
import time
import random
from functools import wraps

# 定义装饰器
def record_time(func):
    """记录函数执行时间的装饰器"""
    
    @wraps(func)  # 关键：保留原函数的元数据（如函数名、文档注释）
    def wrapper(*args, **kwargs):
        # 1. 函数执行前记录时间
        start = time.time()
        
        # 2. 执行原函数
        result = func(*args, **kwargs)
        
        # 3. 函数执行后记录时间并计算耗时
        end = time.time()
        print(f'【{func.__name__}】执行时间: {end - start:.2f}秒')
        
        return result
        
    return wrapper
```

### 1.3 如何使用装饰器？
Python 提供了 `@` 语法糖，可以非常方便地将装饰器应用到函数上。

```python
@record_time
def download(filename):
    """下载文件函数"""
    print(f'开始下载 {filename}...')
    time.sleep(random.random() * 2)
    print(f'{filename} 下载完成.')

@record_time
def upload(filename):
    """上传文件函数"""
    print(f'开始上传 {filename}...')
    time.sleep(random.random() * 3)
    print(f'{filename} 上传完成.')

# 测试调用
download('MySQL从删库到跑路.avi')
upload('Python从入门到住院.pdf')
```

**关键点说明**：
*   `@record_time` 等价于 `download = record_time(download)`。
*   `*args` 和 `**kwargs` 保证了装饰器可以接受任意参数的函数。
*   `@wraps(func)` 是一个最佳实践，它能保留被装饰函数的原始信息（如 `__name__`），否则函数名会变成 `wrapper`。

---

## 2. 递归调用 (Recursion)

### 2.1 什么是递归？
递归是指**函数直接或间接调用自身**的过程。
递归通常用于解决那些可以拆分为更小规模同类子问题的问题（如：阶乘、斐波那契数列、汉诺塔、目录遍历）。

### 2.2 核心要素
1.  **收敛条件（基准情况）**：能够让递归停止的条件，防止无限循环。
2.  **递归公式**：将问题分解为更小子问题的规则。

### 2.3 示例：计算阶乘
非负整数 `N` 的阶乘定义为：`N! = N × (N-1)!`，且 `0! = 1`。

```python
def factorial(num):
    """计算阶乘"""
    # 1. 收敛条件：0 或 1 的阶乘为 1
    if num in (0, 1):
        return 1
    # 2. 递归公式
    return num * factorial(num - 1)

print(f'5! = {factorial(5)}')  # 输出: 120
```

### 2.4 ⚠️ 递归的风险：栈溢出
函数调用会利用内存中的**栈 (Stack)** 结构来保存执行现场。每调用一次函数，栈深度就会增加一层。
*   如果递归层数过深（例如 `factorial(5000)`），会导致 **栈溢出 (Stack Overflow)**，抛出 `RecursionError`。
*   **原则**：递归调用一定要确保能快速收敛。

### 2.5 进阶：斐波那契数列与性能优化
斐波那契数列：1, 1, 2, 3, 5, 8, 13...
公式：`f(n) = f(n-1) + f(n-2)`

**普通递归 (性能存在陷阱)**
```python
def fib(n):
    if n in (1, 2):
        return 1
    return fib(n - 1) + fib(n - 2)
```
**问题**：计算 `fib(n)` 时会进行大量重复计算（例如计算 `fib(5)` 需要多次计算 `fib(3)`），导致效率随 `n` 增大呈指数级下降。

**优化：使用 `lru_cache`**
利用 `functools.lru_cache` 装饰器，可以**缓存**函数的计算结果，避免重复运算。这是递归优化的常见手段。

```python
from functools import lru_cache

@lru_cache(maxsize=128)  # 缓存最近使用的 128 个结果
def fib_optimized(n):
    if n in (1, 2):
        return 1
    return fib_optimized(n - 1) + fib_optimized(n - 2)

# 测试性能
for i in range(1, 51):
    print(f'fib({i}) = {fib_optimized(i)}')
```
加上装饰器后，计算速度会有质的飞跃。

---

## 3. 总结

| 特性 | 描述 | 关键点 |
| :--- | :--- | :--- |
| **装饰器** | 增强函数功能 | `@语法糖`, `@wraps`, `*args/**kwargs` |
| **递归** | 函数调用自身 | 收敛条件, 递归公式, 栈溢出风险, `lru_cache` 优化 |

掌握这两个特性，将使你的 Python 编程水平迈上一个新的台阶！

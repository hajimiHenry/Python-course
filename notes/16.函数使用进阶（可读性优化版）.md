## 函数使用进阶（可读性优化版）

> 说明：这是对原文《16.函数使用进阶.md》的结构与表达做的“可读性优化”版本；核心知识点保持一致，同时补充了少量更容易理解的提示与注意事项。

我们继续探索函数的进阶用法：**把函数当作数据来使用**。一旦你理解了“函数也是对象”，很多看起来“高级”的写法都会变得自然。

### 你将学到

- 什么是“一等函数”（first-class function）
- 什么是“高阶函数”（higher-order function）
- `filter` / `map` / `sorted` 这些常见高阶函数怎么用、怎么选
- 什么时候用 `lambda`，什么时候坚决别用
- 什么是偏函数（`functools.partial`），它能解决什么重复劳动

### 一等函数：函数也是对象

在 Python 中，函数是一等对象（first-class function），意味着它具备和普通数据一样的“待遇”：

1. 函数可以赋值给变量
2. 函数可以作为另一个函数的参数
3. 函数可以作为另一个函数的返回值

先记住一个最重要的区分：

- `func`：函数对象（“这个工具本身”）
- `func()`：调用函数得到返回值（“用工具干活后的结果”）

示例：

```python
def greet(name):
    return f'Hello, {name}!'

f = greet          # 这里没有括号，表示把“函数本身”交给变量f
print(f('Alice'))  # 这里有括号，表示调用函数
```

### 高阶函数：把“变化的部分”当参数传进去

高阶函数（higher-order function）就是：**接收函数作为参数** 或 **返回一个函数** 的函数。

我们从一个例子出发：传入任意多个参数，只把其中 `int` / `float` 类型的元素拿来参与运算。

如果我们把“运算规则”写死在函数内部，比如只能做加法，那么这个函数就不够通用。更好的做法是：把“怎么算”这件事交给外部，通过参数传进来，这样就实现了**解耦**。

```python
def calc(init_value, op_func, *args, **kwargs):
    """对传入的数值（int/float）做归约运算。

    - init_value: 初始值（例如求和用0，求积用1）
    - op_func: 二元运算函数（例如加法、乘法，或自定义）
    """
    items = list(args) + list(kwargs.values())
    result = init_value
    for item in items:
        if isinstance(item, (int, float)):
            result = op_func(result, item)
    return result
```

我们先准备两个“运算规则”（二元函数）：

```python
def add(x, y):
    return x + y


def mul(x, y):
    return x * y
```

调用时只需要“换规则”，不需要改 `calc` 的实现：

```python
print(calc(0, add, 1, 2, 3, 4, 5))  # 15
print(calc(1, mul, 1, 2, 3, 4, 5))  # 120
```

> 小提示：把函数作为参数传递时，写函数名即可（`add` / `mul`）；只有在“调用函数”时才写括号（`add(...)` / `mul(...)`）。

如果不想自己写 `add` / `mul`，可以直接使用标准库 `operator` 模块里提供的函数：

```python
import operator

print(calc(0, operator.add, 1, 2, 3, 4, 5))  # 15
print(calc(1, operator.mul, 1, 2, 3, 4, 5))  # 120
```

### 常见高阶函数：filter / map / sorted

Python 内置函数里有很多高阶函数。它们本质上是在帮你把“遍历”变得更清晰：

- `filter`：过滤（留下符合条件的）
- `map`：映射（把每个元素变成另一个东西）
- `sorted`：排序（支持 `key=` 自定义规则）

#### filter + map：过滤后再映射

例子：去掉奇数，只对偶数平方。

```python
def is_even(num):
    return num % 2 == 0


def square(num):
    return num ** 2


old_nums = [35, 12, 8, 99, 60, 52]
new_nums = list(map(square, filter(is_even, old_nums)))
print(new_nums)  # [144, 64, 3600, 2704]
```

同样的逻辑，用列表生成式通常更直观（也更推荐）：

```python
old_nums = [35, 12, 8, 99, 60, 52]
new_nums = [num ** 2 for num in old_nums if num % 2 == 0]
print(new_nums)  # [144, 64, 3600, 2704]
```

> 注意：在 Python 3 中，`map` 和 `filter` 返回的是迭代器，所以很多时候需要用 `list(...)` 才能直接看到结果。

#### sorted：用 key 参数定义“排序规则”

`sorted` 和列表的 `sort()` 很像，但有两个关键区别：

- `sorted(x)`：返回**新列表**，不修改原数据（更偏函数式、无副作用）
- `list.sort()`：**原地排序**，会修改原列表

默认按字母表顺序排序：

```python
old_strings = ['in', 'apple', 'zoo', 'waxberry', 'pear']
new_strings = sorted(old_strings)
print(new_strings)  # ['apple', 'in', 'pear', 'waxberry', 'zoo']
```

如果想按“长度”排序，把规则通过 `key` 参数传进去即可：

```python
old_strings = ['in', 'apple', 'zoo', 'waxberry', 'pear']
new_strings = sorted(old_strings, key=len)
print(new_strings)  # ['in', 'zoo', 'pear', 'apple', 'waxberry']
```

### lambda：短小临时的匿名函数

当你需要传入一个函数，但这个函数非常简单、只用一次、用 `def` 反而显得啰嗦时，可以使用 `lambda`。

lambda 的语法是：

```python
lambda 参数1, 参数2, ...: 表达式
```

等价于（注意：lambda 只能写一行表达式）：

```python
def func(参数1, 参数2, ...):
    return 表达式
```

把前面的例子改成 lambda：

```python
old_nums = [35, 12, 8, 99, 60, 52]
new_nums = list(map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, old_nums)))
print(new_nums)  # [144, 64, 3600, 2704]
```

> 建议：lambda 一旦嵌套太深、表达式太长，就会迅速降低可读性；这时请果断换回 `def` 并起一个好名字。

#### 一个“看起来很酷但要谨慎”的例子：reduce / all

下面展示如何用一行代码写阶乘和素数判断（更偏技巧展示）。

```python
import functools
import operator

fac = lambda n: functools.reduce(operator.mul, range(2, n + 1), 1)
is_prime = lambda x: x > 1 and all(x % f for f in range(2, int(x ** 0.5) + 1))

print(fac(6))        # 720
print(is_prime(37))  # True
```

这里出现了两个你应该认识的“套路”：

- `functools.reduce(func, iterable, init)`：把一串数据用 `func` 归约成一个结果（例如连乘、连加）
- `all(iterable)`：只要 iterable 里所有值都为真，返回 `True`；只要出现一个假，返回 `False`

### 偏函数：用 partial 固定部分参数

偏函数（partial）可以把“某些参数经常固定不变”的函数，包装成一个更方便的新函数。你可以把它理解为“把常用配置做成快捷方式”。

例如，`int` 默认把字符串按十进制转换；如果我们把 `base` 固定住，就能得到更好用的转换函数：

```python
import functools

int2 = functools.partial(int, base=2)
int8 = functools.partial(int, base=8)
int16 = functools.partial(int, base=16)

print(int('1001'))    # 1001
print(int2('1001'))   # 9
print(int8('1001'))   # 513
print(int16('1001'))  # 4097
```

### 总结

- Python 的函数是一等对象：能赋值、能传参、能返回。
- 高阶函数的关键价值：把“变化的规则”抽离出来，让代码更通用、更可复用。
- lambda 适合短小、临时、读起来不费劲的场景；否则用 `def` 起名往往更清晰。
- `partial` 适合把“重复传同一组参数”的场景做简化，让调用更顺手。

